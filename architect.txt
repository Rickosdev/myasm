マイ・アセンブラの設計（byC言語ますたー◆Cmaster.z.）

2ちゃんねるのニュー速VIP板というところでコテハンやってます。
行けばだいたい会えますので興味ある方は是非声を掛けてください！

以下設計（雑です。あまり他人が読むことを想定していません。）

概要
書くのはエディタ付きアセンブラです。
構成ファイルをもとにアセンブルします。
コマンドライン引数から逆アセンブルも可能という仕様にするつもりです
用意するものは3つ
本体、アセンブルするソースファイル、構成ファイル

詳細

構成ファイルの仕様から。
インテルのSDMのような感じで書く。
例）04 ib ADD AL,imm8
ただし、ファイルの先頭に
opcode = ADD
という記述が必要。また、ファイル名はオペコード単体にしなければならない（拡張子無し）

次に本体の仕様です。
あらかじめシンボルテーブルというのを用意します。
シンボルというのは、構成ファイルで使われるibやALなどの予約済みのトークンです。
構成ファイルのトークンは基本的にスペースを区切り文字とします。
構成ファイルはすべて”instruction”というディレクトリに置きます。
その中のファイルをすべて展開し、読み込めないものやディレクトリはすべて無視します。
FILE構造体へのポインタの配列を作り、入れます。
その際、オペコードテーブルを作ります。
ファイル先頭で宣言されるopcode=ADDの部分より生成します。
トークンを順次取り出し、Trans構造体を形成していきます。
Trans構造体は、関数ポインタの配列へのポインタを2つ保持するものとします。
アセンブル用と逆アセンブル用です。
その他に構成ファイルで新たに定義されるシンボルの情報なども含むかもしれません。
関数ポインタにはトークン同士を比較する関数へのポインタを格納します。
例えば、r/m8というシンボルがあった場合、アセンブラソースファイルのトークンがr/m8であるかどうかを比較し、
真偽を返す関数を関数ポインタの配列に格納します。
構成ファイルを1行読み出すごとに関数ポインタの配列にNULLを追加します。
これは、あとあと関数ポインタの配列中の関数を順次実行していく際、NULLを終端とするためです。
Trans構造体の形成が終わったら、ソースをアセンブルします。
終わり。

エディタの方は別プログラムです。
コメントの認識や、オペコードの認識、オペランドの認識とフォーマットを行います。
ファイルの作成、保存をサポートします。
作成したアセンブリはワンクリックで実行形式にしてくれるようにします。（予定）
逆アセもこのウィンドウで結果の表示を行い、編集やデバッグまでできます。（予定）
ワンステップ実行モードとかを入れる予定です。レジスタの表示は当然やります。スタックも。

以上
